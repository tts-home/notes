<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-interview docs-version-current docs-doc-page docs-doc-id-database/elastic_search" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.5.2">
<title data-rh="true">Elastic Search  |  🤟 👍 🤘</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://tts-home.github.io/notes/interview/database/elastic_search"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-interview-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-interview-current"><meta data-rh="true" property="og:title" content="Elastic Search  |  🤟 👍 🤘"><meta data-rh="true" name="description" content="倒排索引"><meta data-rh="true" property="og:description" content="倒排索引"><link data-rh="true" rel="icon" href="/notes/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://tts-home.github.io/notes/interview/database/elastic_search"><link data-rh="true" rel="alternate" href="https://tts-home.github.io/notes/interview/database/elastic_search" hreflang="en"><link data-rh="true" rel="alternate" href="https://tts-home.github.io/notes/interview/database/elastic_search" hreflang="x-default"><link rel="stylesheet" href="/notes/assets/css/styles.09f60acf.css">
<script src="/notes/assets/js/runtime~main.3226e656.js" defer="defer"></script>
<script src="/notes/assets/js/main.3c48c977.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" target="_self" href="/notes/"><div class="navbar__logo"><img src="/notes/img/tts.png" alt="TTS" class="themedComponent_mlkZ themedComponent--light_NVdE" height="32" width="32"><img src="/notes/img/tts.png" alt="TTS" class="themedComponent_mlkZ themedComponent--dark_xIcU" height="32" width="32"></div><b class="navbar__title text--truncate">Coding Notes</b></a></div><div class="navbar__items navbar__items--right"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" target="_self" href="/notes/interview">Interview</a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently dark mode)" aria-label="Switch between dark and light mode (currently dark mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd sidebarWithHideableNavbar_wUlq"><a tabindex="-1" class="sidebarLogo_isFc" target="_self" href="/notes/"><img src="/notes/img/tts.png" alt="TTS" class="themedComponent_mlkZ themedComponent--light_NVdE" height="32" width="32"><img src="/notes/img/tts.png" alt="TTS" class="themedComponent_mlkZ themedComponent--dark_xIcU" height="32" width="32"><b>Coding Notes</b></a><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/notes/interview">Interview</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/notes/interview/base/collection_map">base</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/notes/interview/cicd/docker">cicd</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/notes/interview/database/elastic_search">database</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/notes/interview/database/elastic_search">Elastic Search</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/interview/database/mysql">MySQL</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/notes/interview/database/redis">Redis</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/notes/interview/framework/mybatis">framework</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/notes/interview/microservice/dubbo">microservice</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/notes/interview/mq/kafka">mq</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/notes/interview/other">Other</a></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/notes/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">database</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Elastic Search</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Elastic Search</h1></header>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="倒排索引">倒排索引<a href="#倒排索引" class="hash-link" aria-label="Direct link to 倒排索引" title="Direct link to 倒排索引">​</a></h2>
<ul>
<li>倒排索引（<code>inverted index</code>）也叫反向索引，有反向索引必有正向索引（<code>forward index</code>）。通俗地来讲，正向索引是通过 <code>key</code> 找 <code>value</code>，反向索引则是通过 <code>value</code> 找 <code>key</code>。</li>
<li>倒排索引主要由单词词典（<code>Term Dictionary</code>）和倒排列表（<code>Posting List</code>）及倒排文件(<code>Inverted File</code>)组成。</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="基本概念">基本概念<a href="#基本概念" class="hash-link" aria-label="Direct link to 基本概念" title="Direct link to 基本概念">​</a></h3>
<ul>
<li><code>Term</code>（单词）：一段文本经过分析器分析以后就会输出一串单词，这一个一个的就叫做 <code>Term</code>（直译为：单词）</li>
<li><code>Term Dictionary</code>（单词字典）：顾名思义，它里面维护的是 <code>Term</code>，可以理解为 <code>Term</code> 的集合</li>
<li><code>Term Index</code>（单词索引）：为了更快的找到某个单词，我们为单词建立索引</li>
<li><code>Posting List</code>（倒排列表）：倒排列表记录了出现过某个单词的所有文档的文档列表及  单词在该文档中出现的位置信息，每条记录称为一个倒排项(<code>Posting</code>)。根据倒排列表，即可获知哪些文档包含某个单词。（PS：实际的倒排列表中并不只是存了<code>文档ID</code>这么简单，还有一些其它的信息，比如：词频（<code>Term</code> 出现的次数）、偏移量（<code>offset</code>）等）</li>
<li><code>Inverted File</code>（倒排文件）：所有单词的倒排列表往往顺序地存储在磁盘的某个文件里，这个文件即被称之为倒排文件，是存储倒排索引的物理文件</li>
<li>在倒排索引中，通过 <code>Term</code> 索引可以找到 <code>Term</code> 在 <code>Term Dictionary</code> 中的位置，进而找到 <code>Posting List</code>，有了倒排列表就可以根据 <code>ID</code> 找到文档了</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="不可变性">不可变性<a href="#不可变性" class="hash-link" aria-label="Direct link to 不可变性" title="Direct link to 不可变性">​</a></h3>
<ul>
<li><code>ES</code> 的底层是基于 <code>Lucene</code>，<code>Lucene</code> 中提出了按段搜索的概念，将一个索引文件拆分为多个子文件，则每个子文件叫作段，每个段都是一个独立的可被搜索的数据集，并且段具有不变性，一旦索引的数据被写入硬盘，就不可再修改</li>
<li>优势<!-- -->
<ul>
<li>不需要锁，如果从来不更新索引，就不需要担心多进程同时修改数据的问题</li>
<li>一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性，只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘，这提供了很大的性能提升</li>
<li>其缓存（像filter缓存）在索引的生命周期内始终有效，它们不需要在每次数据改变时被重建，因为数据不会变化</li>
<li>写入单个大的倒排索引允许数据被压缩，减少磁盘 <code>I/O</code> 和 需要被缓存到内存的索引的使用量</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="提交点">提交点<a href="#提交点" class="hash-link" aria-label="Direct link to 提交点" title="Direct link to 提交点">​</a></h3>
<ul>
<li>为了提升写的性能，<code>Lucene</code> 并没有每新增一条数据就增加一个段，而是采用延迟写的策略，每当有新增的数据时，就将其先写入内存中，然后批量写入磁盘中。若有一个段被写到硬盘，就会生成一个提交点，提交点就是一个列出了所有已知段和记录所有提交后的段信息的文件。</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="索引合并">索引合并<a href="#索引合并" class="hash-link" aria-label="Direct link to 索引合并" title="Direct link to 索引合并">​</a></h3>
<ul>
<li>索引文件中绝大部分数据都是只写一次，读多次，而只有用于保存文档删除信息的文件才会被多次更改。在某些时刻，当某种条件满足时，多个索引段会被拷贝合并到一个更大的索引段，而那些旧的索引段会被抛弃并从磁盘中删除，这个操作称为段合并（<code>segment merging</code>）。</li>
<li>优点<!-- -->
<ul>
<li>当多个索引段合并为一个的时候，会减少索引段的数量并提高搜索速度</li>
<li>同时也会减少索引的容量（文档数），因为在段合并时会移除被标记为已删除的那些文档</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="合并策略">合并策略<a href="#合并策略" class="hash-link" aria-label="Direct link to 合并策略" title="Direct link to 合并策略">​</a></h3>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="tiered默认"><code>tiered</code>（默认）<a href="#tiered默认" class="hash-link" aria-label="Direct link to tiered默认" title="Direct link to tiered默认">​</a></h4>
<ul>
<li>能合并大小相似的索引段，并考虑每层允许的索引段的最大个数。</li>
<li>在索引期，该合并策略会计算索引中允许出现的索引段个数，该数值称为阈值（<code>budget</code>）。如果正在构建的索引中的段数超过了阈值，该策略将先对索引段按容量降序排序（这里考虑了被标记为已删除的文档），然后再选择一个成本最低的合并。合并成本的计算方法倾向于回收更多删除文档和产生更小的索引段。</li>
<li>如果某次合并产生的索引段的大小大于 <code>index.merge.policy.max_merged_segment</code> 参数值，则该合并策略会选择更少的索引段参与合并，使得生成的索引段的大小小于阈值。这意味着，对于有多个分片的索引，默认的 <code>index.merge.policy.max_merged_segment</code> 则显得过小，会导致大量索引段的创建，从而降低查询速度。用户应该根据自己具体的数据量，观察索引段的状况，不断调整合并策略以满足应用需求。</li>
</ul>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="log_byte_size"><code>log_byte_size</code><a href="#log_byte_size" class="hash-link" aria-label="Direct link to log_byte_size" title="Direct link to log_byte_size">​</a></h4>
<ul>
<li>会不断地以字节数的对数为计算单位，选择多个索引来合并创建新索引。</li>
<li>合并过程中，时不时会出现一些较大的索引段，然后又产生出一些小于合并因子（<code>merge factor</code>）的索引段，如此循环往复。</li>
<li>能够保持较少的索引段数量并且极小化段索引合并的代价。</li>
</ul>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="log_doc"><code>log_doc</code><a href="#log_doc" class="hash-link" aria-label="Direct link to log_doc" title="Direct link to log_doc">​</a></h4>
<ul>
<li>与 <code>log_byte_size</code> 合并策略类似，不同的是以索引段的文档数为计算单位。</li>
<li>以下两种情况中该合并策略表现良好<!-- -->
<ul>
<li>文档集中的文档大小类似</li>
<li>期望参与合并的索引段在文档数方面相当</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="es-集群"><code>ES</code> 集群<a href="#es-集群" class="hash-link" aria-label="Direct link to es-集群" title="Direct link to es-集群">​</a></h2>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="相关概念">相关概念<a href="#相关概念" class="hash-link" aria-label="Direct link to 相关概念" title="Direct link to 相关概念">​</a></h3>
<ul>
<li>集群（<code>cluster</code>）：一组拥有共同的 <code>cluster name</code> 的节点</li>
<li>节点（<code>node</code>) ：集群中的一个 <code>ElasticSearch</code> 实例</li>
<li>索引（<code>index</code>) ：<code>ElasticSearch</code> 实例存储数据的地方，相当于关系数据库中的 <code>database</code> 概念</li>
<li>分片（<code>shard</code>）：索引可以被拆分为不同的部分进行存储，称为分片，在集群环境下，一个索引的不同分片可以拆分到不同的节点中</li>
<li>主分片（<code>Primary shard</code>）：相对于副本分片的定义</li>
<li>副本分片（<code>Replica shard</code>）：每个主分片可以有一个或者多个副本，数据和主分片一样</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="节点角色">节点角色<a href="#节点角色" class="hash-link" aria-label="Direct link to 节点角色" title="Direct link to 节点角色">​</a></h3>
<ul>
<li><code>Master</code>
<ul>
<li><code>node.master: true</code> 节点可以作为主节点</li>
</ul>
</li>
<li><code>DataNode</code>
<ul>
<li><code>node.data: true</code> 默认是数据节点</li>
</ul>
</li>
<li><code>Coordinate node</code>
<ul>
<li>协调节点，如果仅担任协调节点，将上两个配置设为 <code>false</code></li>
</ul>
</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="选主流程">选主流程<a href="#选主流程" class="hash-link" aria-label="Direct link to 选主流程" title="Direct link to 选主流程">​</a></h3>
<ul>
<li><code>ES</code> 的选主是 <code>ZenDiscovery</code> 模块负责的，主要包含 <code>Ping</code> 和 <code>Unicast</code>两部分。<!-- -->
<ol>
<li>对所有可以成为 <code>master</code> 的节点根据 <code>nodeId</code> 字典排序，每次选举每个节点都把自己所知道的节点排一次序，然后选出第一个节点，暂且认为它是 <code>master</code> 节点</li>
<li>如果对某个节点的投票数达到一定的值（<code>discovery.zen.minimum_master_nodes</code>）并且该节点自己也选举自己，那这个节点就是 <code>master</code>，否则重新选举一直到满足上述条件</li>
</ol>
</li>
<li><code>master</code> 节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="脑裂问题">脑裂问题<a href="#脑裂问题" class="hash-link" aria-label="Direct link to 脑裂问题" title="Direct link to 脑裂问题">​</a></h3>
<ul>
<li>一个集群中只有一个 <code>A</code> 主节点，<code>A</code> 主节点因为需要处理的东西太多或者网络过于繁忙，从而导致其他从节点 <code>ping</code> 不通 <code>A</code> 主节点，这样其他从节点就会认为 <code>A</code> 主节点不可用了，就会重新选出一个新的主节点 <code>B</code>。过了一会 <code>A</code> 主节点恢复正常了，这样就出现了两个主节点，导致一部分数据来源于 <code>A</code> 主节点，另外一部分数据来源于 <code>B</code> 主节点，出现数据不一致问题，这就是脑裂。</li>
<li>尽量避免脑裂，需要添加最小数量的主节点配置<!-- -->
<ul>
<li><code>discovery.zen.minimum_master_nodes</code>: <code>(N / 2) + 1</code></li>
<li>这个参数控制的是选举主节点时需要的最少的具有 <code>master</code> 资格的活节点数，<code>N</code> 为具有 <code>master</code> 资格的节点的数 量</li>
</ul>
</li>
<li>常用做法（中大规模集群）<!-- -->
<ol>
<li>角色分离<!-- -->
<ul>
<li><code>Master</code> 和 <code>dataNode</code> 角色分开，限制角色，配置奇数个 <code>master</code></li>
</ul>
</li>
<li>单播发现机制<!-- -->
<ul>
<li><code>discovery.zen.ping.multicast.enabled: false</code> 关闭多播发现机制，默认是关闭的</li>
<li><code>discovery.zen.ping.unicast.hosts: [&quot;master1&quot;, &quot;master2&quot;, &quot;master3&quot;]</code> 配置单播发现的主节点 <code>ip</code> 地址，从节点要加入进来，就得去询问单播发现机制里面配置的主节点，主节点同意以后才能加入，然后主节点再通知集群中的其他节点有新节点加入</li>
</ul>
</li>
<li>选主触发<!-- -->
<ul>
<li><code>discovery.zen.minimum_master_nodes: 2</code> 选举主节点时需要的最少的具有 <code>master</code> 资格的活节点数</li>
</ul>
</li>
<li>减少误判<!-- -->
<ul>
<li><code>discovery.zen.ping_timeout: 30</code>（默认值是3秒） 其他节点 <code>ping</code> 主节点多长时间没有响应就认为主节点不可用了</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="分片数量设置">分片数量设置<a href="#分片数量设置" class="hash-link" aria-label="Direct link to 分片数量设置" title="Direct link to 分片数量设置">​</a></h3>
<ul>
<li>分片数指定后不可变，除非重索引</li>
</ul>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="分片过多的影响">分片过多的影响<a href="#分片过多的影响" class="hash-link" aria-label="Direct link to 分片过多的影响" title="Direct link to 分片过多的影响">​</a></h4>
<ul>
<li>每个分片本质上就是一个 <code>Lucene</code> 索引，因此会消耗相应的文件句柄，内存和 <code>CPU</code> 资源</li>
<li>每个搜索请求会调度到索引的每个分片中，如果分片分散在不同的节点问题不太，但当分片开始竞争相同的 硬件资源时, 性能便会逐步下降</li>
<li><code>ES</code> 使用词频统计来计算相关性，当然这些统计也会分配到各个分片上，如果在大量分片上只维护了很少的数据，则将导致最终的文档相关性较差</li>
</ul>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="分片设置参考原则">分片设置参考原则<a href="#分片设置参考原则" class="hash-link" aria-label="Direct link to 分片设置参考原则" title="Direct link to 分片设置参考原则">​</a></h4>
<ul>
<li><code>ES</code> 推荐的最大 <code>JVM</code> 堆空间是 <code>30 ~ 32G</code>, 所以分片最大容量可限制为 <code>30GB</code>, 然后再对分片数量做合理估算</li>
<li>在开始阶段, 一个好的方案是根据节点数量按照 <code>1.5 ~ 3</code> 倍的原则来创建分片，当性能下降时，增加节点，<code>ES</code> 会平衡分片的放置</li>
<li>对于基于日期的索引需求, 并且对索引数据的搜索场景非常少，也许这些索引量将达到成百上千，但每个索引的数据量只有 <code>1GB</code> 甚至更小，对于这种类似场景, 建议只需要为索引分配 <code>1</code> 个分片</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="分片副本设置">分片副本设置<a href="#分片副本设置" class="hash-link" aria-label="Direct link to 分片副本设置" title="Direct link to 分片副本设置">​</a></h3>
<ul>
<li>副本数可以随时调整</li>
</ul>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="副本的用途">副本的用途<a href="#副本的用途" class="hash-link" aria-label="Direct link to 副本的用途" title="Direct link to 副本的用途">​</a></h4>
<ul>
<li>备份数据保证高可用数据不丢失，高并发的时候参与数据查询</li>
</ul>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="副本设置基本原则">副本设置基本原则<a href="#副本设置基本原则" class="hash-link" aria-label="Direct link to 副本设置基本原则" title="Direct link to 副本设置基本原则">​</a></h4>
<ul>
<li>为保证高可用，副本数设置为 <code>2</code> 即可，要求集群至少要有3个节点，来分开存放主分片、副本</li>
<li>如发现并发量大时，查询性能会下降，可增加副本数，来提升并发查询能力</li>
</ul>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="索引文档流程index">索引文档流程（<code>index</code>）<a href="#索引文档流程index" class="hash-link" aria-label="Direct link to 索引文档流程index" title="Direct link to 索引文档流程index">​</a></h2>
<ol>
<li>协调节点默认使用<code>文档ID</code>将索引请求路由到合适的索引分片</li>
<li>索引分片所在的节点接收到来自协调节点的请求后，会将请求写入到 <code>Memory Buffer</code>，然后定时（默认是每隔 <code>1</code> 秒）写入到 <code>Filesystem Cache</code>，这个从 <code>Memory Buffer</code> 到 <code>Filesystem Cache</code> 的过程就叫做 <code>refresh</code></li>
<li>在某些情况下，存在 <code>Momery Buffer</code> 和 <code>Filesystem Cache</code> 的数据可能会丢失，<code>ES</code> 会通过 <code>translog</code> 的机制来保证数据的可靠性，其实现机制是接收到请求后，同时也会写入索引到 <code>translog</code> 中，当 <code>Filesystem Cache</code> 中的数据写入到磁盘中时，才会清除掉，这个过程叫做 <code>flush</code></li>
<li>在 <code>flush</code> 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 <code>fsync</code> 将创建一个新的提交点，并将内容刷新到磁盘，旧的 <code>translog</code> 将被删除并开始一个新的 <code>translog</code>，<code>flush</code> 触发的时机是定时触发（默认 <code>30</code> 分钟）或者 <code>translog</code> 变得太大（默认为 <code>512M</code>）时</li>
</ol>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="更新和删除文档的流程update-delete">更新和删除文档的流程（<code>update</code>, <code>delete</code>）<a href="#更新和删除文档的流程update-delete" class="hash-link" aria-label="Direct link to 更新和删除文档的流程update-delete" title="Direct link to 更新和删除文档的流程update-delete">​</a></h2>
<ul>
<li>删除和更新都是写操作，但 <code>Elasticsearch</code> 中的文档是不可变的，因此不能被删除或者改动以展示其变更</li>
<li>磁盘上的每个段都有一个相应的 <code>.del</code> 文件，当删除请求发送后，文档并没有真的被删除，而是在 <code>.del</code> 文件中被标记为删除，该文档依然能匹配查询，但是会在结果中被过滤掉，当段合并时，在 <code>.del</code> 文件中被标记为删除的文档将不会被写入新段</li>
<li>在新的文档被创建时，<code>Elasticsearch</code> 会为该文档指定一个版本号，当执行更新时，旧版本的文档在 <code>.del</code> 文件中被标记为删除，新版本的文档被索引到一个新段，旧版本的文档依然能匹配查询，但是会在结果中被过滤掉</li>
</ul>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="搜索流程bulk">搜索流程（<code>bulk</code>）<a href="#搜索流程bulk" class="hash-link" aria-label="Direct link to 搜索流程bulk" title="Direct link to 搜索流程bulk">​</a></h2>
<ul>
<li>搜索被执行成一个两阶段过程，我们称之为 <code>Query Then Fetch</code>
<ol>
<li>在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片），每个分片在本地执行搜索并构建一个匹配文档的大小为 <code>from + size</code> 的优先队列（在搜索的时候是会查询<code>Filesystem Cache</code> 的，但是有部分数据还在 <code>Memory Buffer</code>，所以搜索是近实时的）</li>
<li>每个分片返回各自优先队列中所有文档的 <code>ID</code> 和排序值给协调节点，它合并这些值到自己的优先  队列中来产生一个全局排序后的结果列表</li>
<li>接下来就是取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 <code>GET</code> 请求，每个分片加载并丰富文档，如果有需要的话，接着返回文档给协调节点，一旦所有的文档都被取回了，协调节点返回结果给客户端</li>
</ol>
</li>
<li><code>Query Then Fetch</code> 的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少的时候可能不够准确，<code>DFS Query Then Fetch</code> 增加了一个预查询的处理，询问 <code>Term</code> 和 <code>Document frequency</code>，这个评分更准确，但是性能会变差。</li>
</ul>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="字典树">字典树<a href="#字典树" class="hash-link" aria-label="Direct link to 字典树" title="Direct link to 字典树">​</a></h2>
<ul>
<li>字典树又称单词查找树，<code>Trie</code> 树，是一种树形结构，是一种哈希树的变种。</li>
<li>典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。</li>
<li>它的优点是利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</li>
<li><code>Trie</code> 的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</li>
<li><code>3</code> 个基本性质<!-- -->
<ul>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串</li>
<li>每个节点的所有子节点包含的字符都不相同</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="调优">调优<a href="#调优" class="hash-link" aria-label="Direct link to 调优" title="Direct link to 调优">​</a></h2>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="控制字段的存储选项">控制字段的存储选项<a href="#控制字段的存储选项" class="hash-link" aria-label="Direct link to 控制字段的存储选项" title="Direct link to 控制字段的存储选项">​</a></h3>
<ul>
<li>可针对使用场景关闭部分字段的存储</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="开启最佳压缩">开启最佳压缩<a href="#开启最佳压缩" class="hash-link" aria-label="Direct link to 开启最佳压缩" title="Direct link to 开启最佳压缩">​</a></h3>
<ul>
<li>对于存储了 <code>_source</code> 字段的 <code>index</code>，可以把 <code>Lucene</code> 适用的压缩算法替换成 <code>DEFLATE</code>，提高数据压缩率</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="bulk-批量写入"><code>bulk</code> 批量写入<a href="#bulk-批量写入" class="hash-link" aria-label="Direct link to bulk-批量写入" title="Direct link to bulk-批量写入">​</a></h3>
<ul>
<li>写入数据时尽量使用 <code>bulk</code> 接口批量写入，提高写入效率，每个 <code>bulk</code> 请求的文档数量设定区间推荐为 <code>1k~1w</code>，具体可根据业务场景选取一个适当的数量</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="调整-translog-同步策略">调整 <code>translog</code> 同步策略<a href="#调整-translog-同步策略" class="hash-link" aria-label="Direct link to 调整-translog-同步策略" title="Direct link to 调整-translog-同步策略">​</a></h3>
<ul>
<li>默认情况下，<code>translog</code> 的持久化策略是对于每个写入请求都做一次 <code>flush</code>，刷新 <code>translog</code> 数据到磁盘上，这种频繁的<code>磁盘IO</code>操作是严重影响写入性能的，如果可以接受一定概率的数据丢失（这种硬件故障的概率很小），可以调整 <code>translog</code> 持久化策略为异步周期性执行，并适当调整 <code>translog</code> 的刷盘周期</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="调整-refresh_interval">调整 <code>refresh_interval</code><a href="#调整-refresh_interval" class="hash-link" aria-label="Direct link to 调整-refresh_interval" title="Direct link to 调整-refresh_interval">​</a></h3>
<ul>
<li>写入 <code>Lucene</code> 的数据，并不是实时可搜索的，必须通过 <code>refresh</code> 的过程把内存中的数据转换成 <code>Lucene</code> 的完整 <code>segment</code>后，才可以被搜索，默认情况下，每一秒会 <code>refresh</code> 一次，产生一个新的 <code>segment</code>，这样会导致产生的 <code>segment</code> 较多，从而 <code>segment merge</code> 较为频繁，系统开销较大，如果对数据的实时可见性要求较低，可以提高 <code>refresh</code> 的时间间隔，降低系统开销</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="merge-并发控制"><code>merge</code> 并发控制<a href="#merge-并发控制" class="hash-link" aria-label="Direct link to merge-并发控制" title="Direct link to merge-并发控制">​</a></h3>
<ul>
<li><code>index.merge.scheduler.max_thread_count</code> 默认值是 <code>Math.max(1, Math.min(4, Runtime.getRuntime().availableProcessors() / 2))</code>，当节点配置的 <code>cpu</code> 核数较高时，<code>merge</code> 占用的资源可能会偏高，影响集群的性能，可以调整某个 <code>index merge</code> 过程的并发</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="写入数据不指定-_id-而是自动产生">写入数据不指定 <code>_id</code> 而是自动产生<a href="#写入数据不指定-_id-而是自动产生" class="hash-link" aria-label="Direct link to 写入数据不指定-_id-而是自动产生" title="Direct link to 写入数据不指定-_id-而是自动产生">​</a></h3>
<ul>
<li>当用户显示指定 <code>_id</code> 写入数据时，会先发起查询来确  定 <code>index</code> 中是否已经有相同 <code>_id</code> 的文档存在，若有则先删除原有文档再写入新文档，这样每次写入时，都会耗费一定的资源做查询，如果用户写入数据时不指定 <code>_id</code>，则通过内部算法产生一个随机的 <code>_id</code>，并且保证 <code>_id</code> 的唯一性，这样就可以跳过查询 <code>_id</code> 的步骤，提高写入效率</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="使用-routing">使用 <code>routing</code><a href="#使用-routing" class="hash-link" aria-label="Direct link to 使用-routing" title="Direct link to 使用-routing">​</a></h3>
<ul>
<li>对于数据量较大的 <code>index</code>，一般会配置多个 <code>shard</code> 来分摊压力。这种场景下，一个查询会同时搜索所有的 <code>shard</code>，然后再将各个 <code>shard</code> 的结果合并返回给用户。对于高并发的小查询场景，每个分片通常仅抓取极少量数据，此时查询过程中的调度开销远大于实际读取数据的开销，且查询速度取决于最慢的一个分片。</li>
<li>开启 <code>routing</code> 功能后，会将 <code>routing</code> 相同的数据写入到同一个分片中（也可以是多个，由 <code>index.routing_partition_size</code> 参数控制）。如果查询时指定 <code>routing</code>，那么只会查询<code>routing</code> 指向的分片，可显著降低调度开销，提升查询效率。</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="为-string-类型的字段选取合适的存储方式">为 <code>string</code> 类型的字段选取合适的存储方式<a href="#为-string-类型的字段选取合适的存储方式" class="hash-link" aria-label="Direct link to 为-string-类型的字段选取合适的存储方式" title="Direct link to 为-string-类型的字段选取合适的存储方式">​</a></h3>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="text-类型默认"><code>text</code> 类型（默认）<a href="#text-类型默认" class="hash-link" aria-label="Direct link to text-类型默认" title="Direct link to text-类型默认">​</a></h4>
<ul>
<li>做分词后存储倒排索引，支持全文检索，可以通过下面几个参数优化其存储方式<!-- -->
<ul>
<li><code>norms</code> - 用于在搜索时计算该文档的 <code>_score</code>（代表这条数据与搜索条件的相关度），如果不需要评分，可以将其关闭</li>
<li><code>index_options</code> - 控制倒排索引中包括哪些信息（<code>docs、freqs、positions、offsets</code>）。对于不太注重 <code>_score/highlighting</code> 的使用场景，可以设为 <code>docs</code> 来降低内存/磁盘资源消耗</li>
<li><code>fields</code> - 用于添加子字段，对于有 <code>sort</code> 和聚合查询需求的场景，可以添加一个 <code>keyword</code> 子字段以支持这两种功能</li>
</ul>
</li>
</ul>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="keyword-类型"><code>keyword</code> 类型<a href="#keyword-类型" class="hash-link" aria-label="Direct link to keyword-类型" title="Direct link to keyword-类型">​</a></h4>
<ul>
<li>不做分词，不支持全文检索，<code>text</code> 分词消耗 <code>CPU</code> 资源，冗余存储 <code>keyword</code> 子字段占用存储空间，如果没有全文索引需求，只是要通过整个字段做搜索，可以设置该字段的类型为 <code>keyword</code>，提升写入速率，降低存储成本</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="使用-query-bool-filter-组合取代普通-query">使用 <code>query-bool-filter</code> 组合取代普通 <code>query</code><a href="#使用-query-bool-filter-组合取代普通-query" class="hash-link" aria-label="Direct link to 使用-query-bool-filter-组合取代普通-query" title="Direct link to 使用-query-bool-filter-组合取代普通-query">​</a></h3>
<ul>
<li>默认情况下，<code>ES</code> 通过一定的算法计算返回的 每条数据与查询语句的相关度，并通过 <code>_score</code> 字段来表征，但对于非全文索引的使用场景，用户并不关心查询结果与查询条件的相关度，只是想精确的查找目标数据，此时，可以通过 <code>query-bool-filter</code> 组合来让 <code>ES</code> 不计算 <code>_score</code>，并且尽可能的缓存 <code>filter</code> 的结果集，供后续包含相同 <code>filter</code> 的查询使用，提高查询效率</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="index-按日期滚动"><code>index</code> 按日期滚动<a href="#index-按日期滚动" class="hash-link" aria-label="Direct link to index-按日期滚动" title="Direct link to index-按日期滚动">​</a></h3>
<ul>
<li>写入的数据最好通过某种方式做分割，存入不同的 <code>index</code>，比如将数据按模块/功能分类，写入不同的 <code>index</code>，然后按照时间去滚动生成 <code>index</code>，这样做的好处是各种数据分开管理不会混淆，也易于提高查询效率，同时 <code>index</code> 按时间滚动，数据过期时删除整个 <code>index</code>，要比一条条删除数据或 <code>delete_by_query</code> 效率高很多，删除整个 <code>index</code> 是直接删除底层文件，而 <code>delete_by_query</code> 是查询-标记-删除</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="按需控制-index-的分片数和副本数">按需控制 <code>index</code> 的分片数和副本数<a href="#按需控制-index-的分片数和副本数" class="hash-link" aria-label="Direct link to 按需控制-index-的分片数和副本数" title="Direct link to 按需控制-index-的分片数和副本数">​</a></h3>
<ul>
<li>对于查询压力较大的 <code>index</code>，可以考虑提高副本数（<code>number_of_replicas</code>），通过多个副本均摊查询压力</li>
<li><code>shard</code> 数量过多，则批量写入/查询请求被分割为过多的子写入/查询，导 致该 <code>index</code>的写入、查询拒绝率上升</li>
<li>对于数据量较大的 <code>index</code>，当其 <code>shard</code> 数量过小时，无法充分利用节点资源，造成机器资源利用率不高或不均衡，影响写入/查询的效率</li>
</ul>
<h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="分词器">分词器<a href="#分词器" class="hash-link" aria-label="Direct link to 分词器" title="Direct link to 分词器">​</a></h2></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/notes/interview/cicd/docker"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Docker</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/notes/interview/database/mysql"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">MySQL</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#倒排索引" class="table-of-contents__link toc-highlight">倒排索引</a><ul><li><a href="#基本概念" class="table-of-contents__link toc-highlight">基本概念</a></li><li><a href="#不可变性" class="table-of-contents__link toc-highlight">不可变性</a></li><li><a href="#提交点" class="table-of-contents__link toc-highlight">提交点</a></li><li><a href="#索引合并" class="table-of-contents__link toc-highlight">索引合并</a></li><li><a href="#合并策略" class="table-of-contents__link toc-highlight">合并策略</a></li></ul></li><li><a href="#es-集群" class="table-of-contents__link toc-highlight"><code>ES</code> 集群</a><ul><li><a href="#相关概念" class="table-of-contents__link toc-highlight">相关概念</a></li><li><a href="#节点角色" class="table-of-contents__link toc-highlight">节点角色</a></li><li><a href="#选主流程" class="table-of-contents__link toc-highlight">选主流程</a></li><li><a href="#脑裂问题" class="table-of-contents__link toc-highlight">脑裂问题</a></li><li><a href="#分片数量设置" class="table-of-contents__link toc-highlight">分片数量设置</a></li><li><a href="#分片副本设置" class="table-of-contents__link toc-highlight">分片副本设置</a></li></ul></li><li><a href="#索引文档流程index" class="table-of-contents__link toc-highlight">索引文档流程（<code>index</code>）</a></li><li><a href="#更新和删除文档的流程update-delete" class="table-of-contents__link toc-highlight">更新和删除文档的流程（<code>update</code>, <code>delete</code>）</a></li><li><a href="#搜索流程bulk" class="table-of-contents__link toc-highlight">搜索流程（<code>bulk</code>）</a></li><li><a href="#字典树" class="table-of-contents__link toc-highlight">字典树</a></li><li><a href="#调优" class="table-of-contents__link toc-highlight">调优</a><ul><li><a href="#控制字段的存储选项" class="table-of-contents__link toc-highlight">控制字段的存储选项</a></li><li><a href="#开启最佳压缩" class="table-of-contents__link toc-highlight">开启最佳压缩</a></li><li><a href="#bulk-批量写入" class="table-of-contents__link toc-highlight"><code>bulk</code> 批量写入</a></li><li><a href="#调整-translog-同步策略" class="table-of-contents__link toc-highlight">调整 <code>translog</code> 同步策略</a></li><li><a href="#调整-refresh_interval" class="table-of-contents__link toc-highlight">调整 <code>refresh_interval</code></a></li><li><a href="#merge-并发控制" class="table-of-contents__link toc-highlight"><code>merge</code> 并发控制</a></li><li><a href="#写入数据不指定-_id-而是自动产生" class="table-of-contents__link toc-highlight">写入数据不指定 <code>_id</code> 而是自动产生</a></li><li><a href="#使用-routing" class="table-of-contents__link toc-highlight">使用 <code>routing</code></a></li><li><a href="#为-string-类型的字段选 取合适的存储方式" class="table-of-contents__link toc-highlight">为 <code>string</code> 类型的字段选取合适的存储方式</a></li><li><a href="#使用-query-bool-filter-组合取代普通-query" class="table-of-contents__link toc-highlight">使用 <code>query-bool-filter</code> 组合取代普通 <code>query</code></a></li><li><a href="#index-按日期滚动" class="table-of-contents__link toc-highlight"><code>index</code> 按日期滚动</a></li><li><a href="#按需控制-index-的分片数和副本数" class="table-of-contents__link toc-highlight">按需控制 <code>index</code> 的分片数和副本数</a></li></ul></li><li><a href="#分词器" class="table-of-contents__link toc-highlight">分词器</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 TTS, Inc. Built with <a href="https://docusaurus.io/" target="_blank">Docusaurus</a>.</div></div></div></footer></div>
</body>
</html>